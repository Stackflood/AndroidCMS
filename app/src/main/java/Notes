#!/usr/bin/env bash

*Whenver got SSLHandshake - protocol error - Android has a bug with REST/SOAP/Http calals being made and paused in between : Don't put debugging breakpoints on such calls.


getPostListAdapter() {
        if (mPostsListAdapter == null) {
            PostsListAdapter.OnLoadMoreListener loadMoreListener = new PostsListAdapter.OnLoadMoreListener() {
                @Override
                public void onLoadMore() {
                    if (mCanLoadMorePosts && !mIsFetchingPosts)
                        requestPosts(true);
                }
            };

            PostsListAdapter.OnPostsLoadedListener postsLoadedListener = new PostsListAdapter.OnPostsLoadedListener() {
                @Override
                public void onPostsLoaded


 pushing commits on git

--> git status

--> git add .

--> git commit -m "Comments"

--> git push origin master

---->
Bundle is most often used for passing
data through various Activities. Provides putType() and getType() methods for storing and retrieving data from it.

--->
An Intent is exactly what it describes. It's an "intention" to do an action.

An Intent is basically a message to say you did or want something to happen. Depending on the intent, apps or the OS might be listening for it and will react accordingly.

Think of it as a blast email to a bunch of friends, in which you tell your friend John to do something. The other folks will ignore the email, but John will react to it.

To listen for an intent (like the phone ringing, or an SMS is received), you implement a broadcast receiver.

If you want to fire off an intent to do something, like pop up the dialer, you fire off an intent saying you will.

intent-based calls are run-time binding.

intent-based invocations are asynchronous.

An Intent provides a facility for performing late runtime binding between the code in different applications. Its most significant use is in the launching of activities, where it can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.

 action -- The general action to be performed, such as ACTION_VIEW, ACTION_EDIT, ACTION_MAIN, etc.

 data -- The data to operate on, such as a person record in the contacts database, expressed as a Uri.



 --> Parcelable

 * Interface for classes whose instances can be written to
  * and restored from a {@link Parcel}.  Classes implementing the Parcelable
  * interface must also have a static field called <code>CREATOR</code>, which
  * is an object implementing the {@link Parcelable.Creator Parcelable.Creator}
  * interface.


  --> Using a synchronized block

      At its simplest level, a block of code that is marked as synchronized in Java tells the JVM: "only let one thread in here at a time".


--> /**
         * Convenience method for inserting a row into the database.
         *
         * @param table the table to insert the row into
         * @param nullColumnHack optional; may be <code>null</code>.
         *            SQL doesn't allow inserting a completely empty row without
         *            naming at least one column name.  If your provided <code>values</code> is
         *            empty, no column names are known and an empty row can't be inserted.
         *            If not set to null, the <code>nullColumnHack</code> parameter
         *            provides the name of nullable column name to explicitly insert a NULL into
         *            in the case where your <code>values</code> is empty.
         * @param values this map contains the initial column values for the
         *            row. The keys should be the column names and the values the
         *            column values
         * @return the row ID of the newly inserted row, or -1 if an error occurred
         */
        public long insert(String table, String nullColumnHack, ContentValues values) {
