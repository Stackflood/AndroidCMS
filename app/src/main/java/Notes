#!/usr/bin/env bash

*Whenver got SSLHandshake - protocol error - Android has a bug with REST/SOAP/Http calals being made and paused in between : Don't put debugging breakpoints on such calls.


getPostListAdapter() {
        if (mPostsListAdapter == null) {
            PostsListAdapter.OnLoadMoreListener loadMoreListener = new PostsListAdapter.OnLoadMoreListener() {
                @Override
                public void onLoadMore() {
                    if (mCanLoadMorePosts && !mIsFetchingPosts)
                        requestPosts(true);
                }
            };

            PostsListAdapter.OnPostsLoadedListener postsLoadedListener = new PostsListAdapter.OnPostsLoadedListener() {
                @Override
                public void onPostsLoaded


 pushing commits on git

--> git status

--> git add .

--> git commit -m "Comments"

--> git push origin master

---->
Bundle is most often used for passing
data through various Activities.
Provides putType() and getType() methods
 for storing and retrieving data from it.

--->
An Intent is exactly what it describes. It's an "intention" to do an action.

An Intent is basically a message to say you did or want something to happen. Depending on the intent, apps or the OS might be listening for it and will react accordingly.

Think of it as a blast email to a bunch of friends, in which you tell your friend John to do something. The other folks will ignore the email, but John will react to it.

To listen for an intent (like the phone ringing, or an SMS is received), you implement a broadcast receiver.

If you want to fire off an intent to do something, like pop up the dialer, you fire off an intent saying you will.

intent-based calls are run-time binding.

intent-based invocations are asynchronous.

An Intent provides a facility for performing late runtime binding between the code in different applications. Its most significant use is in the launching of activities, where it can be thought of as the glue between activities. It is basically a passive data structure
 holding an abstract description of an action to be performed.

 action -- The general action to be performed, such as ACTION_VIEW, ACTION_EDIT, ACTION_MAIN, etc.

 data -- The data to operate on, such as a person record in the contacts database, expressed as a Uri.



 --> Parcelable

 * Interface for classes whose instances can be written to
  * and restored from a {@link Parcel}.  Classes implementing the Parcelable
  * interface must also have a static field called <code>CREATOR</code>, which
  * is an object implementing the {@link Parcelable.Creator Parcelable.Creator}
  * interface.


  --> Using a synchronized block

      At its simplest level, a block of code that is marked as synchronized in Java tells the JVM: "only let one thread in here at a time".


--> /**
         * Convenience method for inserting a row into the database.
         *
         * @param table the table to insert the row into
         * @param nullColumnHack optional; may be <code>null</code>.
         *            SQL doesn't allow inserting a completely empty row without
         *            naming at least one column name.  If your provided <code>values</code> is
         *            empty, no column names are known and an empty row can't be inserted.
         *            If not set to null, the <code>nullColumnHack</code> parameter
         *            provides the name of nullable column name to explicitly insert a NULL into
         *            in the case where your <code>values</code> is empty.
         * @param values this map contains the initial column values for the
         *            row. The keys should be the column names and the values the
         *            column values
         * @return the row ID of the newly inserted row, or -1 if an error occurred
         */
        public long insert(String table, String nullColumnHack, ContentValues values) {


--->

attr.xml
<declare-styleable name="FlowLayout"> ==
 TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.FlowLayout);


 --->
View.getTag() It's basically a way for views to have memories.


---->

/**
 * The SwipeRefreshLayout should be used whenever the user can refresh the
 * contents of a view via a vertical swipe gesture. The activity that
 * instantiates this view should add an OnRefreshListener to be notified
 * whenever the swipe to refresh gesture is completed. The SwipeRefreshLayout
 * will notify the listener each and every time the gesture is completed again;
 * the listener is responsible for correctly determining when to actually
 * initiate a refresh of its content. If the listener determines there should
 * not be a refresh, it must call setRefreshing(false) to cancel any visual
 * indication of a refresh. If an activity wishes to show just the progress
 * animation, it should call setRefreshing(true). To disable the gesture and
 * progress animation, call setEnabled(false) on the view.
 * <p>
 * This layout should be made the parent of the view that will be refreshed as a
 * result of the gesture and can only support one direct child. This view will
 * also be made the target of the gesture and will be forced to match both the
 * width and the height supplied in this layout. The SwipeRefreshLayout does not
 * provide accessibility events; instead, a menu item must be provided to allow
 * refresh of the content wherever this gesture is used.
 * </p>
 */
public class SwipeRefreshLayout extends ViewGroup

--->

SparseArrays map integers to Objects.  Unlike a normal array of Objects,
 * there can be gaps in the indices.  It is intended to be more memory efficient
 * than using a HashMap to map Integers to Objects, both because it avoids
 * auto-boxing keys and its data structure doesn't rely on an extra entry object
 * for each mapping.

 --->

 /**
      * Causes the Runnable r to be added to the message queue.
      * The runnable will be run on the thread to which this handler is
      * attached.
      *
      * @param r The Runnable that will be executed.
      *
      * @return Returns true if the Runnable was successfully placed in to the
      *         message queue.  Returns false on failure, usually because the
      *         looper processing the message queue is exiting.
      */
     public final boolean post(Runnable r)
     {
        return  sendMessageDelayed(getPostMessage(r), 0);
     }


 ---->

     HANDLERS :
     http://developer.android.com/reference/android/os/Handler.html

 --->

 Example of RELATIVE LAYOUTS

 http://developer.android.com/guide/topics/ui/layout/relative.html


 --> Frame is not available

 Issue doing database access such as :

 Cursor c = db.query(CATEGORIES_TABLE, new String[]


 -->
 To go to next activity : startActivityForResult-- using intent
 i=intent
 r= request code
 startActivityForResult(i,r);

 getting back :
 setResult(RESULT_OK, mIntent);
                     finish();


 ---> ViewStub

 The < include /> will just include the xml contents in your base xml file as if the whole thing was just a single big file. It’s a nice way to share layout parts between different layouts.The < ViewStub /> is a bit different because it is not directly included, and will be loaded only when you actually use it/need it, i.e, when you set it’s visibility to “true”. This a nice optimization because you could have a complex layout with tons of small views or headers anywhere, and still have your Activity load up really fast.
  Once you use one of those views, it’ll be loaded.


  ----> Broadcast

  A broadcast receiver (short receiver) is an Android component which allows you to register for system or application events.
  All registered receivers for an event are notified by the Android runtime once this event happens.

  ---> Android Video Uploader has problems - --- > all versions






